/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * German Language Learning API
 * API for managing German words, phrases, components, examples, and semantic groups.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  GetAllErrorsApiTrainingErrorsAllGetParams,
  GetConfidenceStatsApiTrainingConfidenceStatsGet200,
  GetConfidenceStatsApiTrainingConfidenceStatsGetParams,
  GetErrorStatsAllApiTrainingErrorStatsAllGet200,
  GetErrorStatsAllApiTrainingErrorStatsAllGetParams,
  GetErrorStatsApiTrainingErrorStatsGet200,
  GetErrorStatsApiTrainingErrorStatsGetParams,
  GetUserErrorsApiTrainingErrorsGetParams,
  HTTPValidationError,
  SpecialTrainingStartApiSpecialTrainingStartPostParams,
  StartTrainingApiTrainingStartPostParams,
  TrainingAnswerRequest,
  TrainingAnswerResponse,
  TrainingRateAnswerRequest,
  UserAnswerError,
  UserCardReviewResponse
} from '.././model';





/**
 * @summary Start Training
 */
export const startTrainingApiTrainingStartPost = (
    params: StartTrainingApiTrainingStartPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/training/start`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getStartTrainingApiTrainingStartPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>, TError,{params: StartTrainingApiTrainingStartPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>, TError,{params: StartTrainingApiTrainingStartPostParams}, TContext> => {

const mutationKey = ['startTrainingApiTrainingStartPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>, {params: StartTrainingApiTrainingStartPostParams}> = (props) => {
          const {params} = props ?? {};

          return  startTrainingApiTrainingStartPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartTrainingApiTrainingStartPostMutationResult = NonNullable<Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>>
    
    export type StartTrainingApiTrainingStartPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Start Training
 */
export const useStartTrainingApiTrainingStartPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>, TError,{params: StartTrainingApiTrainingStartPostParams}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof startTrainingApiTrainingStartPost>>,
        TError,
        {params: StartTrainingApiTrainingStartPostParams},
        TContext
      > => {

      const mutationOptions = getStartTrainingApiTrainingStartPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Special Training Start
 */
export const specialTrainingStartApiSpecialTrainingStartPost = (
    params: SpecialTrainingStartApiSpecialTrainingStartPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/special-training/start`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSpecialTrainingStartApiSpecialTrainingStartPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>, TError,{params: SpecialTrainingStartApiSpecialTrainingStartPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>, TError,{params: SpecialTrainingStartApiSpecialTrainingStartPostParams}, TContext> => {

const mutationKey = ['specialTrainingStartApiSpecialTrainingStartPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>, {params: SpecialTrainingStartApiSpecialTrainingStartPostParams}> = (props) => {
          const {params} = props ?? {};

          return  specialTrainingStartApiSpecialTrainingStartPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SpecialTrainingStartApiSpecialTrainingStartPostMutationResult = NonNullable<Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>>
    
    export type SpecialTrainingStartApiSpecialTrainingStartPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Special Training Start
 */
export const useSpecialTrainingStartApiSpecialTrainingStartPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>, TError,{params: SpecialTrainingStartApiSpecialTrainingStartPostParams}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof specialTrainingStartApiSpecialTrainingStartPost>>,
        TError,
        {params: SpecialTrainingStartApiSpecialTrainingStartPostParams},
        TContext
      > => {

      const mutationOptions = getSpecialTrainingStartApiSpecialTrainingStartPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Submit Answer
 */
export const submitAnswerApiTrainingSubmitAnswerPost = (
    trainingAnswerRequest: TrainingAnswerRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingAnswerResponse>> => {
    
    
    return axios.default.post(
      `/api/training/submit_answer`,
      trainingAnswerRequest,options
    );
  }



export const getSubmitAnswerApiTrainingSubmitAnswerPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>, TError,{data: TrainingAnswerRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>, TError,{data: TrainingAnswerRequest}, TContext> => {

const mutationKey = ['submitAnswerApiTrainingSubmitAnswerPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>, {data: TrainingAnswerRequest}> = (props) => {
          const {data} = props ?? {};

          return  submitAnswerApiTrainingSubmitAnswerPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitAnswerApiTrainingSubmitAnswerPostMutationResult = NonNullable<Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>>
    export type SubmitAnswerApiTrainingSubmitAnswerPostMutationBody = TrainingAnswerRequest
    export type SubmitAnswerApiTrainingSubmitAnswerPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Submit Answer
 */
export const useSubmitAnswerApiTrainingSubmitAnswerPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>, TError,{data: TrainingAnswerRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof submitAnswerApiTrainingSubmitAnswerPost>>,
        TError,
        {data: TrainingAnswerRequest},
        TContext
      > => {

      const mutationOptions = getSubmitAnswerApiTrainingSubmitAnswerPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Rate Answer
 */
export const rateAnswerApiTrainingRateAnswerPost = (
    trainingRateAnswerRequest: TrainingRateAnswerRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCardReviewResponse>> => {
    
    
    return axios.default.post(
      `/api/training/rate_answer`,
      trainingRateAnswerRequest,options
    );
  }



export const getRateAnswerApiTrainingRateAnswerPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>, TError,{data: TrainingRateAnswerRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>, TError,{data: TrainingRateAnswerRequest}, TContext> => {

const mutationKey = ['rateAnswerApiTrainingRateAnswerPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>, {data: TrainingRateAnswerRequest}> = (props) => {
          const {data} = props ?? {};

          return  rateAnswerApiTrainingRateAnswerPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RateAnswerApiTrainingRateAnswerPostMutationResult = NonNullable<Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>>
    export type RateAnswerApiTrainingRateAnswerPostMutationBody = TrainingRateAnswerRequest
    export type RateAnswerApiTrainingRateAnswerPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Rate Answer
 */
export const useRateAnswerApiTrainingRateAnswerPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>, TError,{data: TrainingRateAnswerRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof rateAnswerApiTrainingRateAnswerPost>>,
        TError,
        {data: TrainingRateAnswerRequest},
        TContext
      > => {

      const mutationOptions = getRateAnswerApiTrainingRateAnswerPostMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Get Error Stats
 */
export const getErrorStatsApiTrainingErrorStatsGet = (
    params?: GetErrorStatsApiTrainingErrorStatsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetErrorStatsApiTrainingErrorStatsGet200>> => {
    
    
    return axios.default.get(
      `/api/training/error_stats`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetErrorStatsApiTrainingErrorStatsGetQueryKey = (params?: GetErrorStatsApiTrainingErrorStatsGetParams,) => {
    return [`/api/training/error_stats`, ...(params ? [params]: [])] as const;
    }

    
export const getGetErrorStatsApiTrainingErrorStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>, TError = AxiosError<HTTPValidationError>>(params?: GetErrorStatsApiTrainingErrorStatsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetErrorStatsApiTrainingErrorStatsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>> = ({ signal }) => getErrorStatsApiTrainingErrorStatsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetErrorStatsApiTrainingErrorStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>>
export type GetErrorStatsApiTrainingErrorStatsGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Error Stats
 */

export function useGetErrorStatsApiTrainingErrorStatsGet<TData = Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: GetErrorStatsApiTrainingErrorStatsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsApiTrainingErrorStatsGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetErrorStatsApiTrainingErrorStatsGetQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get User Errors
 */
export const getUserErrorsApiTrainingErrorsGet = (
    params?: GetUserErrorsApiTrainingErrorsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAnswerError[]>> => {
    
    
    return axios.default.get(
      `/api/training/errors`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUserErrorsApiTrainingErrorsGetQueryKey = (params?: GetUserErrorsApiTrainingErrorsGetParams,) => {
    return [`/api/training/errors`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserErrorsApiTrainingErrorsGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>, TError = AxiosError<HTTPValidationError>>(params?: GetUserErrorsApiTrainingErrorsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserErrorsApiTrainingErrorsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>> = ({ signal }) => getUserErrorsApiTrainingErrorsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserErrorsApiTrainingErrorsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>>
export type GetUserErrorsApiTrainingErrorsGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get User Errors
 */

export function useGetUserErrorsApiTrainingErrorsGet<TData = Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: GetUserErrorsApiTrainingErrorsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserErrorsApiTrainingErrorsGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserErrorsApiTrainingErrorsGetQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Confidence Stats
 */
export const getConfidenceStatsApiTrainingConfidenceStatsGet = (
    params?: GetConfidenceStatsApiTrainingConfidenceStatsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetConfidenceStatsApiTrainingConfidenceStatsGet200>> => {
    
    
    return axios.default.get(
      `/api/training/confidence_stats`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConfidenceStatsApiTrainingConfidenceStatsGetQueryKey = (params?: GetConfidenceStatsApiTrainingConfidenceStatsGetParams,) => {
    return [`/api/training/confidence_stats`, ...(params ? [params]: [])] as const;
    }

    
export const getGetConfidenceStatsApiTrainingConfidenceStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>, TError = AxiosError<HTTPValidationError>>(params?: GetConfidenceStatsApiTrainingConfidenceStatsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfidenceStatsApiTrainingConfidenceStatsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>> = ({ signal }) => getConfidenceStatsApiTrainingConfidenceStatsGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetConfidenceStatsApiTrainingConfidenceStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>>
export type GetConfidenceStatsApiTrainingConfidenceStatsGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Confidence Stats
 */

export function useGetConfidenceStatsApiTrainingConfidenceStatsGet<TData = Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: GetConfidenceStatsApiTrainingConfidenceStatsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConfidenceStatsApiTrainingConfidenceStatsGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetConfidenceStatsApiTrainingConfidenceStatsGetQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Error Stats All
 */
export const getErrorStatsAllApiTrainingErrorStatsAllGet = (
    params?: GetErrorStatsAllApiTrainingErrorStatsAllGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetErrorStatsAllApiTrainingErrorStatsAllGet200>> => {
    
    
    return axios.default.get(
      `/api/training/error_stats/all`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetErrorStatsAllApiTrainingErrorStatsAllGetQueryKey = (params?: GetErrorStatsAllApiTrainingErrorStatsAllGetParams,) => {
    return [`/api/training/error_stats/all`, ...(params ? [params]: [])] as const;
    }

    
export const getGetErrorStatsAllApiTrainingErrorStatsAllGetQueryOptions = <TData = Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>, TError = AxiosError<HTTPValidationError>>(params?: GetErrorStatsAllApiTrainingErrorStatsAllGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetErrorStatsAllApiTrainingErrorStatsAllGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>> = ({ signal }) => getErrorStatsAllApiTrainingErrorStatsAllGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetErrorStatsAllApiTrainingErrorStatsAllGetQueryResult = NonNullable<Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>>
export type GetErrorStatsAllApiTrainingErrorStatsAllGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get Error Stats All
 */

export function useGetErrorStatsAllApiTrainingErrorStatsAllGet<TData = Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: GetErrorStatsAllApiTrainingErrorStatsAllGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getErrorStatsAllApiTrainingErrorStatsAllGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetErrorStatsAllApiTrainingErrorStatsAllGetQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get All Errors
 */
export const getAllErrorsApiTrainingErrorsAllGet = (
    params?: GetAllErrorsApiTrainingErrorsAllGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAnswerError[]>> => {
    
    
    return axios.default.get(
      `/api/training/errors/all`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAllErrorsApiTrainingErrorsAllGetQueryKey = (params?: GetAllErrorsApiTrainingErrorsAllGetParams,) => {
    return [`/api/training/errors/all`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllErrorsApiTrainingErrorsAllGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>, TError = AxiosError<HTTPValidationError>>(params?: GetAllErrorsApiTrainingErrorsAllGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllErrorsApiTrainingErrorsAllGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>> = ({ signal }) => getAllErrorsApiTrainingErrorsAllGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllErrorsApiTrainingErrorsAllGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>>
export type GetAllErrorsApiTrainingErrorsAllGetQueryError = AxiosError<HTTPValidationError>


/**
 * @summary Get All Errors
 */

export function useGetAllErrorsApiTrainingErrorsAllGet<TData = Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: GetAllErrorsApiTrainingErrorsAllGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllErrorsApiTrainingErrorsAllGet>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAllErrorsApiTrainingErrorsAllGetQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



